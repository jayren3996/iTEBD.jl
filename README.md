# iTEBD.jl

Julia package for infinite time-evolution block-decimation (iTEBD) calculation.

## Introduction

This julia package is for iTEBD algorithms, introduced by G. Vidal (PRL.91.147902, PRL.98.070201, PRB.78.155117), to simulate time evolution of 1D infinite size systems. The iTEBD algorithm relies on a Trotter-Suzuki and subsequent approximation of the time-evolution operator. It provides an extremely efficient method to study both the short time evolution and the ground state (using imaginary time evolution) of 1-D gapped system.

## Installation

The package can be installed in julia ```REPL```:

```julia
pkg> add https://github.com/jayren3996/iTEBD.jl
```

## Code Examples

### iMPS objects

The states in iTEBD algorithm are represented by infinite matrix-product-states (iMPS):

```julia
struct iMPS{T<:Number}
    Γ::Vector{Array{TΓ, 3}}
    λ::Vector{Vector{Float64}}
    n::Integer
end
```

Here we use a slightly different representation with that of Vidal's. The tensor `Γ[i]` already contain the Schmidt spectrum `λ[i]`, which means when brought to canonical form, each `Γ[i]` is right-canonical, while `λ[i]` contains the entanglement information.

There is a function `rand_iMPS(n::Integer,d::Integer,dim::Integer)` that generates a random iMPS with `n` periodic sites, `d` local degrees of freedom, and bond dimension `dim`.

With a set of given tensors, a `iMPS` object can be explicitly constructed by `iMPS(Γ)`.

### Hamiltonian

An Hamiltonian is just a matrix. For example, AKLT Hamiltoniancan be constructed by:

```julia
using LinearAlgebra
x = sqrt(2)/2 * [0 1 0; 1 0 1; 0 1 0]
y = sqrt(2)/2 * 1im * [0 -1 0; 1 0 -1; 0 1 0]
z = [1 0 0; 0 0 0; 0 0 -1]
hamiltonian = begin
    SS = kron(x,x)+kron(y,y)+kron(z,z)
    1/2 * SS + 1/6 * SS^2 + 1/3*I
end
```

### iTEBD

The iTEBD algorithm is generated by applying local gate iteratively. To do that, we use the `applygate!` function:

```julia
function applygate!(
    ψ::iMPS, G::AbstractMatrix,
    i::Integer, j::Integer;
    maxdim=MAXDIM, cutoff=SVDTOL, renormalize=true
)
```

where `ψ` is the `iMPS` object, `G` is the local gate represented by matrix, `i` and `j` specify the region on which the gate is applied on. The additional agruments `maxdim`, `cutoff`, and `renormalize` control the maximal bond dimension, singular value cutoff, and whether renormalize the singular values. 

We show an explict example of solving the ground state of AKLT Hamiltonian by imaginary-time iTEBD:

```julia
using iTEBD, LinearAlgebra

# Create gate for iTEBD
const gate = begin
    dτ = 0.1
    x = sqrt(2)/2 * [0 1 0; 1 0 1; 0 1 0]
	y = sqrt(2)/2 * 1im * [0 -1 0; 1 0 -1; 0 1 0]
	z = [1 0 0; 0 0 0; 0 0 -1]
    SS = kron(x,x)+kron(y,y)+kron(z,z)
	H = 1/2 * SS + 1/6 * SS^2 + 1/3*I
    expH = exp(- dτ * H)
end

# Exact AKLT ground state
const aklt = begin
    tensor = zeros(2,3,2)
    tensor[1,1,2] = +sqrt(2/3)
    tensor[1,2,1] = -sqrt(1/3)
    tensor[2,2,2] = +sqrt(1/3)
    tensor[2,3,1] = -sqrt(2/3)
    iMPS([tensor, tensor])
end

# Setup TEBD
function main()
    psi = rand_iMPS(ComplexF64, 2, 3, 1)
    for i=1:500
        applygate!(psi, gate, 1, 2, maxdim=8)
        applygate!(psi, gate, 2, 1, maxdim=8)
        if mod(i, 10) == 0
            println("Overlap: ", inner_product(aklt, psi))
        end
    end
end
main()
```

Here we calculate the inner product of intermediate state and the exact AKLT ground state. We see the overlap quickly converges to 1.

