# iTEBD.jl

Julia package for infinite time-evolution block-decimation (iTEBD) calculation.

## Introduction

This julia package is for iTEBD algorithms, introduced by G. Vidal (PRL.91.147902, PRL.98.070201, PRB.78.155117), to simulate time evolution of 1D infinite size systems. The iTEBD algorithm relies on a Trotter-Suzuki and subsequent approximation of the time-evolution operator. It provides an extremely efficient method to study both the short time evolution and the ground state (using imaginary time evolution) of 1-D gapped system.

## Installation

The package can be installed in julia ```REPL```:

```julia
pkg> add https://github.com/jayren3996/iTEBD.jl
```

## Code Examples

### iMPS objects

The states in iTEBD algorithm are represented by infinite matrix-product-states (iMPS):

```julia
struct iMPS{T<:Number}
    Γ::Vector{Array{TΓ, 3}}
    λ::Vector{Vector{Float64}}
    n::Integer
end
```

Here we use a slightly different representation with that of Vidal's. The tensor `Γ[i]` already contain the Schmidt spectrum `λ[i]`, which means when brought to canonical form, each `Γ[i]` is right-canonical, while `λ[i]` contains the entanglement information.

There is a function `rand_iMPS(n::Integer,d::Integer,dim::Integer)` that generates a random iMPS with `n` periodic sites, `d` local degrees of freedom, and bond dimension `dim`.

With a set of given tensors, a `iMPS` object can be explicitly constructed by `iMPS(Γ)`.

### Hamiltonian

An Hamiltonian is just an  `Array{T,2}`. There is also a helper function `spin` for constructing spin Hamiltonian. For example, AKLT Hamiltoniancan be constructed by:

```julia
hamiltonian = begin
    SS = spin((1,"xx"), (1,"yy"), (1,"zz"), D=3)
    SS + 1/3 * SS^2
end
```

### Trotter-gate iTEBD

The Trotter-gate iTEBD algorithm is generated by applying local gate iteratively. To do that, we use the `GATE` object:

```julia
struct GATE{T<:Number}
    mat::Matrix{T}
    inds::Vector{Int64}
    bound::Int64
    cutoff::Float64
    renormalize::Bool
end
```

where `mat` is the local operator, `inds` is the sites it act on, ```bound``` controls the truncation of the singular values, and ```cutoff``` controls the minimal value of the singular value below witch the singular value will be discarded, and ```renormalize``` controls whether to renorm the Schmidt spectrum in the simulation (which is necessary in the non-unitary evolution, such as imaginary-time iTEBD).

The `GATE` can be constructed by the function `gate gate(mat, ind; kwargs...)`, where the control parameters have default value and can be set using keyward arguments. Then we can apply the gate to the iMPS using function `applygate!(mps::iMPS, gate::GATE)` to evolve the system.

We show an explict example of solving the ground state of AKLT Hamiltonian by imaginary-time iTEBD:

```julia
using iTEBD
using iTEBD: spin

BOND = 50
DT = 0.01
# Create random iMPS
imps = rand_iMPS(ComplexF64, 2, 3, BOND)

# Create gate for iTEBD
GA, GB = begin
    ss = spin((1,"xx"), (1,"yy"), (1,"zz"), D=3)
    H = ss + 1/3 * ss^2
    expH = exp(- DT * H)
    gate(expH, [1,2], bound=BOND), gate(expH, [2,1], bound=BOND)
end

# Exact AKLT ground state
aklt = begin
    tensor = zeros(2,3,2)
    tensor[1,1,2] = +sqrt(2/3)
    tensor[1,2,1] = -sqrt(1/3)
    tensor[2,2,2] = +sqrt(1/3)
    tensor[2,3,1] = -sqrt(2/3)
    iMPS([tensor, tensor])
end

# Setup TEBD
for i=1:2000
    global imps, aklt, GA, GB
    applygate!(imps, GA)
    applygate!(imps, GB)
    if mod(i, 100) == 0
        println("Overlap: ", inner_product(aklt, imps))
    end
end
```

Here we calculate the inner product of intermediate state and the exact AKLT ground state. We see the overlap quickly converges to 1.

### Canonical form

In many cases, it is much simpler to work on the canonical form of MPS. Here, the canonical form is the right-canonical form. However, we keep track of the Schmidt values so that it can easily transformed to Schmidt canonical form.

The Schmidt canonical form is obtained using the function `canonical(imps::iMPS; kwargs...)`. This method assume the dominent right eigenvector is positive definite. When set `trim=true` in the keyword argument, it will search if the iMPS can be block decomposed, and will keep the smallest block if mutiple blocks are found. 

If the total block decomposition is wanted, we shoud first group the iMPS to a single tensor using function `group(mps::iMPS)`. The function `block_canonical(Γ::AbstractArray{<:Number, 3})` will search the block decomposition of `Γ`. Since the algorithm is probabilistic, there are chances that the decomposition is still ruducible. Further more, if the iMPS is highly singular, namely, the condition number for its transfer matrix is large, this algorithm would fail to compute the right answer.
